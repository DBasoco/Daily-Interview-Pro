# Today we have: Create a Balanced Binary Search Tree Given a sorted list of numbers, change it into a balanced
# binary search tree. You can assume there will be no duplicate numbers in the list.

from collections import deque
import math


class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

    def __str__(self):
        nodes = deque([self])
        answer = ''
        while len(nodes):
            node = nodes.popleft()
            if not node:
                continue
            answer += str(node.value)
            nodes.append(node.left)
            nodes.append(node.right)
        return answer

    # I am not familiar with binary trees in terms of this question. I am assuming they are similar to recursive trees.


# I am also unfamiliar with this called module deque So the number in the tree is the center of the list,
# and then the second layer is the centers of the two sublists generated by the removal of the 4
def createBalancedBST(nums):
    x = len(nums)
    if x is not 0:
        com = math.floor(x / 2)
        sol = Node(nums[com], Node(numsif nums[com] is not 0)
        x = com

    # sol = Node(nums[math.floor(len(nums) / 2)], Node(nums[math.floor(len(nums) / 4)], nums[math.floor(len(nums) / 6)],

# Node(4, Node(2, 1, 3), Node(6, 5, 7)) So this is what I'm trying to get to
# I could use remove but that has a big time scale since each search it runs through the whole list.



print(createBalancedBST([1, 2, 3, 4, 5, 6, 7]))  # 4261357

#   4
#  / \
# 2   6
# / \ / \
# 1 3 5 7
